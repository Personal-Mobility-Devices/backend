# Исследовательская работа: оптимизация подгрузки парковок в приложении

## Суть задачи

В нашем приложении пользователь может просматривать карту Москвы с парковками. Каждая парковка хранится в базе данных 
в таблице parkings, где есть информация о координатах (широта и долгота), описании, названии, административной зоне, 
загруженности и других характеристиках.

Проблема заключается в том, что в базе данных может быть десятки тысяч парковок, и если при каждом обновлении карты 
или скролле загружать все записи сразу, _интерфейс пользователя будет сильно тормозить_.

**Поэтому необходимо оптимизировать запросы к базе данных, чтобы возвращались только те парковки, которые видны на 
текущем участке карты. Другими словами, при скролле карты пользователю нужно подгружать только те парковки, которые 
попадают в область видимости (bbox, “bounding box”), а не всю базу сразу.**

## Основные подходы к решению

### 1. Не хранить координаты в виде JSON

Сейчас координаты парковок хранятся в формате jsonb как объект вида {"lat": 55.7, "lon": 37.6}.

**Плюсы**: удобно хранить несколько значений в одном поле.

**Минусы**: базы данных плохо оптимизируют поиск по данным внутри JSON. При запросе на видимые парковки PostgreSQL 
вынужден проверять каждую запись, что очень медленно.

### 2. Использование отдельных полей lat/lon и индексов

Каждое поле — это обычное числовое значение (DOUBLE PRECISION).

_По этим полям можно создавать индексы, которые ускоряют поиск._
- **Индексы** — это специальные структуры данных, которые позволяют быстро находить записи без перебора всей таблицы.

Индекс по широте:

`CREATE INDEX idx_parkings_lat ON parkings (lat);`

Индекс по долготе:

` CREATE INDEX idx_parkings_lon ON parkings (lon); `

Запрос для поиска парковок в видимой области (bbox) выглядит так:

`SELECT * FROM parkings WHERE lat BETWEEN <lat_min> AND <lat_max> AND lon BETWEEN <lon_min> AND <lon_max>;
`

Без индекса база читает все строки простым перебором, что очень долго.

С индексом PostgreSQL идет по дереву индекса, сразу находит подходящие записи → **экономится время**.

### 3. Использование геометрических типов (PostGIS)

- PostGIS — это мощное расширение с открытым исходным кодом для PostgreSQL, которое превращает его в полноценную 
пространственную базу данных. Оно позволяет выполнять сложные пространственные операции, такие как поиск объектов 
в радиусе, расчет расстояний, определение пересечений и работу с картами, используя стандартные SQL-запросы и 
пространственные индексы для высокой производительности.

Внутри PostGIS есть тип данных **geometry**, который позволяет хранить координаты как точку в пространстве (Point).

Добавляем новое поле (geom - название может быть любым) в таблицу:

`ALTER TABLE parkings ADD COLUMN geom geometry(Point, 4326);`

Если имеем отдельные lat\lon поля вместо coordinates, заполняем значением новое поле:

`UPDATE parkings
SET geom = ST_SetSRID(ST_MakePoint(lon, lat), 4326);`

Вставка новой записи в таблицу (новой парковки) упрощенно будет выглядеть так:

`INSERT INTO parkings (description, lat, lon, geom)
VALUES ('Парковка у ТЦ', 55.75, 37.62, ST_SetSRID(ST_MakePoint(37.62, 55.75), 4326));
`

_*В ST_MakePoint сначала долгота, потом широта._

- ST_MakePoint - создает точку на основе координат lon, lat.
- ST_SetSRID - задает точке систему координат WGS84 (долгота\широта на земной поверхности, код 4326)

**Для оптимизации поиска записей создаем GiST (Generalized Search Tree) индекс - идеален для пространственных данных 
(геометрия).**

`CREATE INDEX idx_parkings_geom_gist ON parkings USING GIST (geom);
`

Запрос в БД будет выглядеть следующим образом:

`SELECT * FROM parkings
WHERE geom && ST_MakeEnvelope(lon_min, lat_min, lon_max, lat_max, 4326);`

- geom - это то самое поле в БД типа geometry.
- ST_MakeEnvelope - создаёт прямоугольник (bbox) видимой области.
- && - оператор, проверяющий пересечение точек с прямоугольником.

**Плюсы**: поиск по карте происходит мгновенно даже при десятках тысяч парковок.

**Минусы**: требует PostGIS, немного сложнее в настройке (надо устанавливать расширение для бд).

### 4. Пагинация и подгрузка по частям

Даже с индексами не стоит загружать все парковки сразу. Рекомендуется:

Делить данные на порции, например, возвращать 100–500 парковок за раз.

Подгружать новые парковки по мере скролла карты (lazy loading - ленивая загрузка).

_Это сокращает нагрузку на сеть и ускоряет отклик интерфейса._

### 5. Кэширование

Можно использовать Redis, чтобы хранить недавно подгруженные парковки.

При повторной загрузке одного и того же участка карты данные берутся из кэша → нет лишних обращений к базе.

Особенно полезно, если у нас есть пользователи, которые часто листают одни и те же районы.

## Вывод

Есть два основных способа:

1. Идеально использовать PostGIS расширение для БД с типом данных geometry и функциями для выявления вхождения точки 
в bbox + GiST индексы. **Это будет самым быстрым и эффективным решением.**

2. Либо если не хочется PostGIS, можно разделить coordinates на отдельные поля lat и lon и создать на них стандартные индексы.
